# SM4 算法查找表优化实验报告

## 1. 引言

本报告旨在详细阐述对 SM4 分组密码算法进行查找表优化的实验原理、过程以及预期结果。SM4 算法是中国国家密码局发布的一种分组密码算法，广泛应用于数据加密。其核心运算之一是 T 变换，包含 S 盒替换和线性变换。通过预计算这些复杂操作的结果并存储在查找表中，可以显著提高算法的执行效率。

## 2. 实验原理

### 2.1 SM4 算法概述

SM4 算法是一种 128 位分组密码，密钥长度为 128 位。它采用非对称的 Feistel 结构，包含 32 轮迭代。每一轮的核心是复杂的 T 变换，其定义为：

$$T(X) = L(\tau(X))$$

其中：
*   $X$ 是一个 32 位的输入字。
*   $\tau(X)$ 是一个非线性变换，它将 $X$ 的每个字节通过 S 盒进行替换，然后将替换后的字节重新组合成一个 32 位字。
*   $L(Y)$ 是一个线性变换，对 $\tau(X)$ 的结果 $Y$ 进行一系列的异或和循环左移操作。

### 2.2 查找表优化原理

T 变换中的 S 盒替换和线性变换涉及较多的位操作和查找。为了提高性能，可以采用查找表（Lookup Table）优化。其核心思想是预先计算所有可能的 T 变换结果，并将这些结果存储在一个表中。

对于 32 位输入 $X$，它可以被视为四个 8 位字节 $X = (x_3 || x_2 || x_1 || x_0)$。T 变换可以分解为对每个字节进行 S 盒替换，然后将结果进行线性变换并异或组合。

查找表优化通过构建一个 $4 \times 256$ 的 $T_{Table}$ 来实现。其中，$T_{Table}[i][j]$ 存储了当第 $i$ 个字节（从低位到高位）为 $j$ 时，经过 S 盒替换和线性变换后的结果。具体地：

*   `T_Table[0][j]` 存储 $L(S\_BOX[j])$
*   `T_Table[1][j]` 存储 $L(S\_BOX[j] \ll 8)$
*   `T_Table[2][j]` 存储 $L(S\_BOX[j] \ll 16)$
*   `T_Table[3][j]` 存储 $L(S\_BOX[j] \ll 24)$

在运行时，当需要计算 $T(X)$ 时，不再执行 S 盒替换和线性变换的位操作，而是直接将 $X$ 的四个字节分别作为索引去查找 $T_{Table}$，并将查找到的四个结果进行异或，即：

$$T(X) = T_{Table}[0][x_0] \oplus T_{Table}[1][x_1] \oplus T_{Table}[2][x_2] \oplus T_{Table}[3][x_3]$$

这种方法用内存查找代替了计算密集型的位操作，从而大大提高了 T 变换的执行速度。

## 3. 实验过程

### 3.1 初始代码准备

实验基于网络上的SM4 算法实现。包含了 SM4 的 S 盒、FK/CK 参数、循环左移、字节替换 (`t_1`)、线性变换 (`l_1`, `l_2`)、复合变换 (`t`, `t_`)、轮密钥生成、加密解密函数以及测试 `main` 函数。

### 3.2 优化代码创建

为了实现查找表优化并将其与原文件分离，创建了一个新的文件 `Project1\sm4_optimized_lookup.cpp`。此文件是 `sm4_implementation.cpp` 的一个副本，并在其基础上进行了以下修改：

1.  **查找表声明：** 在全局范围声明了一个静态的 `uint32_t T_Table[4][256];`。
2.  **查找表初始化函数：** 添加了一个名为 `init_sm4_tables()` 的函数。该函数在程序启动时被调用（在 `main` 函数中），负责遍历所有 256 个可能的字节值，并计算其经过 S 盒和线性变换后的结果，填充到 `T_Table` 中。
    ```cpp
    void init_sm4_tables() {
        for (int i = 0; i < 256; ++i) {
            uint32_t sbox_out = S_BOX[i];
            T_Table[0][i] = l_1(sbox_out);
            T_Table[1][i] = l_1(sbox_out << 8);
            T_Table[2][i] = l_1(sbox_out << 16);
            T_Table[3][i] = l_1(sbox_out << 24);
        }
    }
    ```
3.  **T 变换函数优化：** 修改了 `t(uint32_t x)` 函数，使其不再执行 `l_1(t_1(x))`，而是直接从 `T_Table` 中查找结果。
    ```cpp
    uint32_t t(uint32_t x) {
        uint8_t a0 = x & 0xFF;
        uint8_t a1 = (x >> 8) & 0xFF;
        uint8_t a2 = (x >> 16) & 0xFF;
        uint8_t a3 = (x >> 24) & 0xFF;
        return T_Table[0][a0] ^ T_Table[1][a1] ^ T_Table[2][a2] ^ T_Table[3][a3];
    }
    ```
4.  **`main` 函数修改：** 在 `main` 函数的开头调用 `init_sm4_tables()`，确保查找表在使用前完成初始化。
5.  **中文乱码处理：** 保留了在 `main` 函数中设置控制台输出编码为 UTF-8 的代码 `SetConsoleOutputCP(CP_UTF8);`，以确保中文输出正常显示。


## 4. 预期结果

1.  **性能提升：** 相较于未优化的版本，`sm4_optimized_lookup.cpp` 中的 SM4 加密和解密操作将显著加快。因为每一轮的 T 变换将由一系列位操作和 S 盒查找（每次 4 次 S 盒查找和多次异或、循环移位）变为简单的内存查找和异或操作（4 次内存查找和 3 次异或）。
2.  **功能正确性：** 优化后的算法在功能上将与原始 SM4 算法完全一致。通过 `main` 函数中的加密、解密和验证过程，预期密文能被正确解密回原始明文，并且程序会输出 "解密验证成功!"。
3.  **中文输出正常：** 由于在 `main` 函数中添加了 `SetConsoleOutputCP(CP_UTF8);`，预期所有中文输出（例如“加密结果”、“解密结果”和“解密验证成功!”）都将正常显示，不再出现乱码。

查找表优化前：
```
加密结果: 2863a1640c182b1fd69dbcdaab8ecee6
解密结果: 0123456789abcdef0123456789abcdef 
解密验证成功!
加密结果: eefead236a24bb44345a3468e19f147c
解密结果: fedcba9876543210fedcba9876543210 
解密验证成功!
...
多次运行下的平均代码执行时间: 676 微秒
```
查找表优化后：
```
加密结果: 855e75e5e720211282fbced0c26ca899
解密结果: b4dc80784f286efa0c4476e056db3262
解密验证成功!
加密结果: b36d063f1206aa5532f5c5ca400a2104
解密结果: d0df07c37e23ab4d9f7aa3bedb55baad
解密验证成功!
...
多次运行下平均代码执行时间: 584 微秒
```
## 5. 结论

本实验成功地将 SM4 算法的 T 变换进行了查找表优化，并成功降低了执行时间。但优化幅度没有课上演示的那么明显，经过查询发现是cin cout函数频繁io造成了更大比例的时间损失。

